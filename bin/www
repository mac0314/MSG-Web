#!/usr/bin/env node

/**
 * Module dependencies.
 */


var app = require('../app');
var debug = require('debug')('myweb:server');
var http = require('http');
var https = require('https');
var fs = require('fs');
var util = require('util');
var config = require('config.json')('./config/config.json');
var xmlbuilder = require('xmlbuilder');

var xml2js = require('xml2js');
var parser = new xml2js.Parser();

var mqtt = require('mqtt');

/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '3000');
app.set('port', port);

/**
 * Create HTTP server.
 */

var server = http.createServer(app);

var io = require('socket.io').listen(server);

// usernames which are currently connected to the chat
var usernames = {};

var mqtt_client = mqtt.connect('mqtt://' + config.iot.mqttproxy);

var data = {
  'username':'',
  'message':''
};

var cseid = 'mobius-yt';
var aeid = '';

var topic = '';

// connection이 발생할 때 핸들러를 실행한다.
io.sockets.on('connection', function (socket) {
    // when the client emits 'adduser', this listens and executes
    console.log("IO connect");

    mqtt_client.on('connect', function () {
        console.log("MQTT Connect");
    });

    socket.on('redirect', function(destination) {
        console.log('redirect');
        window.location.href = destination;
    });

	  socket.on('adduser', function(username){
        console.log('adduser');
        // store the username in the socket session for this client
		    socket.username = username;

        console.log(socket.username);

		    // add the client's username to the global list
		    usernames[username] = username;

        console.log(usernames[username]);


    });

    socket.on('chooseroom', function(roomname){
      try{
        console.log('unsubscribe : /oneM2M/req/#');
        mqtt_client.unsubscribe('/oneM2M/req/#');
      }catch(exception){
        console.log(exception);
      }
      console.log('chooseroom');
      // store the room name in the socket session for this client
      socket.room = roomname;
      // send client to room 1
      socket.join(socket.room);

      //console.log(socket.room);
      //console.log(socket.username);


      aeid = roomname;

      topic = '/oneM2M/req/' + aeid + '/:' + cseid + '/xml';
      mqtt_client.subscribe(topic);

      //socket.emit('updaterooms', global.rooms, socket.room);

      console.log('subscribe : ' + topic);


      data.username = 'SERVER';
      data.message = "Admin has connected to this room";

      var dataStr = JSON.stringify(data);
      //console.log('dataStr : ' + dataStr);


      var dataXML = xmlbuilder.create('m2m:rqp', {'encoding':'UTF-8'}).att('xmlns:m2m', 'http://www.onem2m.org/xml/protocols').att('xmlns:xsi', 'http://www.w3.org/2001/XMLSchema-instance')
        .ele('op', '1').up()
        .ele('to', '/mobius-yt'+ aeid +'/chatting').up()
        .ele('fr', 'S0.2.481.1.20160721051547725').up()
        .ele('rqi', 'rqi201607211554337900rzY').up()
        .ele('ty', '4').up()
        .ele('pc').ele('cin').ele('rn', ' ').up()
        .ele('con', data.message)
        .end({ pretty: true});

      //console.log(dataXML);

      //mqtt_client.publish(topic,  dataXML);
      //mqtt_client.publish(socket.room,  dataStr);

    });

    mqtt_client.on('message', function (topic, data) {
        //console.log('message : ' + data);

        parser.parseString(data, function(err, result){
          sResult = JSON.stringify(result);
          oResult = JSON.parse(sResult);
          //console.log(oResult);

          var con = oResult['m2m:rqp']['pc'][0]['cin'][0]['con'];

          //console.log(Object.keys(oResult['m2m:rqp']['pc'][0]['cin'][0]['con']));
          //console.log(con);
          var roomname = {};
          roomname = topic.split('/');
          console.log(roomname);

          if(roomname[3] == socket.room){
            socket.emit('updatechat', con.toString());
          }

        });
    });

    // listener, whenever the server emits 'updatechat', this updates the chat body
    socket.on('leaveroom', function (rooms) {

        for(var i=0; i<rooms.length; i++){
            aeid = rooms[i];

            topic = '/oneM2M/req/' + aeid + '/:' + cseid + '/xml';

            mqtt_client.unsubscribe(topic);
        }
    });

    // when the client emits 'sendchat', this listens and executes
	  socket.on('sendchat', function (message) {
          console.log('sendchat _ data : ' + message);
          //console.log(socket.room);
		      // we tell the client to execute 'updatechat' with 2 parameters
		      //io.sockets.in(socket.room).emit('updatechat', socket.username, data);
          data.username = socket.username;
          data.message = message;

          var user = "Admin";

          var con =  user + ": " + data.message;

          //var dataStr = JSON.stringify(data);

          var dataXML = xmlbuilder.create('m2m:rqp', {'encoding':'UTF-8'}).att('xmlns:m2m', 'http://www.onem2m.org/xml/protocols').att('xmlns:xsi', 'http://www.w3.org/2001/XMLSchema-instance')
            .ele('op', '1').up()
            .ele('to', '/mobius-yt/Sajouiot03/chatting').up()
            .ele('fr', 'S0.2.481.1.20161001051547725').up()
            .ele('rqi', 'rqi201610011554337900rzY').up()
            .ele('ty', '4').up()
            .ele('pc').ele('cin').ele('rn', '').up()
            .ele('con', con)
            .end({ pretty: true});

          //console.log(dataXML);


          aeid = socket.room;

          topic = '/oneM2M/req/' + aeid + '/:' + cseid + '/xml';

          mqtt_client.publish(topic,  dataXML);
	  });


/*
    socket.on('switchRoom', function(newroom){
		    // leave the current room (stored in session)
		    socket.leave(socket.room);

        mqtt_client.unsubscribe(socket.room);
        console.log('switchRoom _ unsubscribe : ' + socket.room);

		    // join new room, received as function parameter
		    socket.join(newroom);
        mqtt_client.subscribe(newroom);
        console.log('switchRoom _ subscribe : ' + newroom);

        data.username = 'SERVER';
        data.message = socket.username + " has connected to this room";
        //var dataStr = JSON.stringify(data);

        //mqtt_client.publish(socket.room,  dataStr);
		    //socket.emit('updatechat', 'SERVER', 'you have connected to '+ newroom);
		    // sent message to OLD room
		    //socket.broadcast.to(socket.room).emit('updatechat', 'SERVER', socket.username+' has left this room');
		    // update socket session room title
		    socket.room = newroom;
		    //socket.broadcast.to(newroom).emit('updatechat', 'SERVER', socket.username+' has joined this room');
		    socket.emit('updaterooms', global.rooms, newroom);
	  });
*/
	  // when the user disconnects.. perform this
	  socket.on('disconnect', function(){
        console.log('disconnect');

        data.message = " has disconnected";
        console.log(socket.room);

        aeid = socket.room;

        topic = '/oneM2M/req/' + aeid + '/:' + cseid + '/xml';

        //mqtt_client.publish(topic,  data.message);


		    // remove the username from global usernames list
		    delete usernames[socket.username];
		    // update list of users in chat, client-side
		    io.sockets.emit('updateusers', usernames);
		    // echo globally that this client has left
		    //socket.broadcast.emit('updatechat', 'Admin has disconnected');
		    socket.leave(socket.room);
        mqtt_client.close;
	  });
});



server.listen(port, function(){
  console.log('Server Listen ' + port + ' port');
});
server.on('error', onError);
server.on('listening', onListening);

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  debug('Listening on ' + bind);
}
